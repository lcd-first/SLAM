# 函数模板

## 1. 概念

概念： 函数模板是通用的函数描述，使用任意类型（泛型） 来描述函数

编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型函数定义。

```c++
#include <iostream> 
using namespace std; 

template <typename T>

void Swap(T & a, T &b) {
    T tmp = a;
    a=b;
    b=tmp;
}
int main() {
     int a= 10, b=20;
    Swap(a,b);
    cout<< "a="<<a<<"b= "<<b<<endl;
    return 0;
}
```



## 2. 注意事项

- 可以为类的成员函数创建模板，但不能是虚函数和析构函数
- 使用函数模板时，必须明确数据类型，确保实参与函数模板能匹配上
- 使用函数模板时，推导的数据类型必须适应函数模板中的代码
- 使用函数模板时，如果是自动类型推导，不会发生隐式类型转换，如果显示指定了函数模板的数据类型，可以发生隐式类型转换
- 函数模板支持多个通用数据类型的参数





## 3. 函数模板具体化



可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板

具体化（特例化，特化）的语法：

```
template<> void 函数模板名<数据类型> (参数列表)
template<> void 函数模板名（参数列表） {
	//函数体
}
```



注意： 

- 普通函数和 函数模板具体化版本在头文件中声明，在源文件定义
- 函数模板 的声明和定义都在头文件



## 4. 函数模板高级

1. decltype 关键字

   在c++ 中，decltype 操作符，用于查阅表达式的数据类型

   语法： decltype(expression) var ;

   decltype 分析表达式并得到它的类型，不会执行表达式，函数调用也是一种表达式，因此不必担心在使用decltype时执行了函数

2. 函数后置返回类型
3. C++ 14 标准对函数返回类型推导规则进行了优化，函数的返回值可以用auto，不必尾随返回类型











































